//version 20171001-using axis-angle.  I hope.

global proc plfmaya_liggghts_part2_deformable()
{



//Begin by defining framerate etc

float $frame_rate = 250;
float $timestep = 0.000001;  //check this is the same is in output below
float $timesteps_per_frame = (1/$frame_rate)/$timestep;

$fileId2 = `fopen "run.liggghts" "w"`;

fprint $fileId2 ("#This LIGGGHTS input file was autoGenerated using Maya->Liggghts script by Peter Falkingham v3 - QUATERNIONS!\n\n");

fprint $fileId2 ("#----------SET UP FOLDER FOR OUTPUT----------#\n\n");
fprint $fileId2 ("shell mkdir post\n\n");

fprint $fileId2 ("#processors 1 1 1\n\n");

fprint $fileId2 ("#----------SYSTEM VARIABLES----------#\n\n");
fprint $fileId2 ("#These are variables used later that get frequently altered\n");
fprint $fileId2 ("variable	r equal 0.001		# RADIUS of the particles (metres)\n");
fprint $fileId2 ("variable	E equal 5.0e7		# Young's modulus of particles (MPa)\n");
fprint $fileId2 ("variable	f equal 0.8		    # Coefficient of Friction (?)\n");
fprint $fileId2 ("variable	c equal 75000		# Cohesion energy density (?)\n");
//For some reason this line no longer works
//fprint $fileId2 ("variable cr equal 0.1         # Coefficient of restitution \n");
fprint $fileId2 ("variable	d equal 1200		# Density of particles (Kg/m3)\n");
fprint $fileId2 ("variable	v equal 0.4		    # Poisson ratio\n");
fprint $fileId2 ("variable	s equal 0.000001		# time step size (seconds)\n");
fprint $fileId2 ("variable	e equal 4000		# dump every\n\n");

fprint $fileId2 ("#----------SIMULATION SETTINGS----------#\n");
fprint $fileId2 ("# These are required for the simulation\n");
fprint $fileId2 ("units 		si				# units are set to SI\n");
fprint $fileId2 ("atom_style 	granular		# standard for DEM - NOTE THAT SPHERE ALSO WORKS\n");
fprint $fileId2 ("boundary	    f f f			    # Boundary s = non-periodic, shrinkwrapped\n");
fprint $fileId2 ("newton 		off				# Turns newtons 3rd law on/off: on = slight computational savings, but 2x more communication\n");
fprint $fileId2 ("communicate	single vel yes	# standard processor communication settings\n");
fprint $fileId2 ("neighbor	    $r bin			    #nearest neighbor course contact detection\n");
fprint $fileId2 ("neigh_modify	every 1 delay 0 check yes	#rebuild list every step, if checked.\n\n");

fprint $fileId2 ("#----------READ THE RESTART FILE----------#\n");
fprint $fileId2 ("read_restart restart.res			# Reads the restart file\n\n");

fprint $fileId2 ("#----------MATERIAL PROPERTIES----------#\n");
fprint $fileId2 ("# These determine the behaviour of the simulation\n");
fprint $fileId2 ("fix	m1 all property/global youngsModulus peratomtype $E\n");
fprint $fileId2 ("fix	m2 all property/global poissonsRatio peratomtype $v\n");
fprint $fileId2 ("fix	m3 all property/global coefficientRestitution peratomtypepair 1 0.1\n");
fprint $fileId2 ("fix 	m4 all property/global coefficientFriction peratomtypepair 1 $f\n");
fprint $fileId2 ("fix 	m5 all property/global characteristicVelocity scalar 1.0\n");
fprint $fileId2 ("fix 	m6 all property/global cohesionEnergyDensity peratomtypepair 1 $c\n\n");

fprint $fileId2 ("#----------FORCE MODEL----------#\n");
fprint $fileId2 ("# Takes the given material properties and applies them to all particles\n");
fprint $fileId2 ("pair_style	gran model hertz tangential history cohesion sjkr tangential_reduce on \n");
fprint $fileId2 ("pair_coeff	* * 			# applies this interaction to all particle pairs\n\n");

fprint $fileId2 ("#----------ADDITIONAL SETTINGS----------#\n");
fprint $fileId2 ("fix 		nsph all nve/sphere			# Initialises time integration\n");
fprint $fileId2 ("fix       gravi all gravity 9.81 vector 0.0 0.0 -1.0	#Gravity\n\n");
fprint $fileId2 ("timestep	$s\n\n");

//Previously had here cutting the atoms, but will move this to setup script

fprint $fileId2 ("#--------INITIALIZATION OF MESHES-----#\n");
fprint $fileId2 ("fix    tray all mesh/surface file simtray.stl type 1\n");  

//Get first animation frame translation + rotation
float $anStart = `playbackOptions -q -minTime`;
currentTime $anStart;
////For loop for each bone

string $bones[] = `ls -sl`;
string $item;

for ($item in $bones)
{

    string $buffer[];
    tokenize $item ":" $buffer;
    string $cleanName = $buffer[size($buffer)-1];

    fprint $fileId2 ("fix    "+$cleanName+" all mesh/surface file "+$cleanName+"_1.stl type 1 curvature_tolerant yes\n"); //rotate axis "+$ax+" "+$ay+" "+$az+" angle "+$ang+" move "+$tx+" "+$ty+" "+$tz+"\n");
}

fprint $fileId2 ("fix cont1 all wall/gran model hertz tangential history mesh n_meshes "+(size($bones)+1)+" meshes tray ");
for ($item in $bones)
{
    string $buffer[];
    tokenize $item ":" $buffer;
    string $cleanName = $buffer[size($buffer)-1];
    fprint $fileId2 (" "+$cleanName+" ");
}
fprint $fileId2 ("\n\n");

fprint $fileId2 ("#--------COMPUTATION----------#\n");
fprint $fileId2 ("# sets up what will be computed\n");
fprint $fileId2 ("compute	rke all erotate/sphere\n");
fprint $fileId2 ("compute 	mudisp all displace/atom\n");
fprint $fileId2 ("#compute	fc all wall/gran/local id pos force\n\n");

fprint $fileId2 ("#----------DUMP FILES----------#\n");
fprint $fileId2 ("dump		dmp all custom $e post/dump*.bin id x y z radius\n");  //Add in 'vx vy vz fx fy fz' for forces and velocities
fprint $fileId2 ("dump 	    dumpstl1 all mesh/vtk $e post/footcomp2_*.vtk id");
for ($item in $bones)
{
    string $buffer[];
    tokenize $item ":" $buffer;
    string $cleanName = $buffer[size($buffer)-1];
    fprint $fileId2 (" "+$cleanName+" ");

}
fprint $fileId2 ("\n");
fprint $fileId2 ("#dump 	    dumpstl2 all mesh/vtk $e post/tray_*.vtk id tray");
fprint $fileId2 ("\n");
fprint $fileId2 ("#dump 		forcedump all local $e post/dump*.forcedata  c_fc[1] c_fc[2] c_fc[3] c_fc[4] c_fc[5] c_fc[6] c_fc[7] c_fc[8] c_fc[9] c_fc[10] c_fc[11] c_fc[12]\n\n");

fprint $fileId2 ("run 4000 #Lets particles settle before motion\n\n");

//turn off outputting tray after a single output file.
fprint $fileId2 ("#undump dumpstl2\n\n");

fprint $fileId2 ("###############################################################\n");
fprint $fileId2 ("##motion\n");
fprint $fileId2 ("###############################################################\n\n");


//cycle through timesteps (frames), calculate translation and rotation required, 

//Declare some variables for within the loops
float $currX;
float $currY;
float $currZ;
float $currRX;
float $currRY;
float $currRZ;
float $prevX;
float $prevY;
float $prevZ;
float $prevRX;
float $prevRY;
float $prevRZ;
float $aangle;
float $s;
float $axisX;
float $axisY;
float $axisZ;

float $anEnd = `playbackOptions -q -maxTime`;
int $i = ($anStart+1);
int $j = $i-1; //time-1

int $p = 0;
float $rots[]; //this and $p are for storign the actual angle it's moving, so that I can use it in unfixing rotations.

python("import maya.OpenMaya as om");  //move out of loop
python("import math"); //move out of loop
python("import pymel.core as pm");
python("rotOrder = om.MEulerRotation.kXYZ");   //move out of loop

for ($i;$i<=$anEnd;++$i)
{
    fprint $fileId2 ("#motions to get to frame "+$i+"\n");
    $p = 0;
    $j = $i-1;
    for ($item in $bones)
    {

    string $buffer[];
    tokenize $item ":" $buffer;
    string $cleanName = $buffer[size($buffer)-1];


        string $nodeString = "node = pm.PyNode('" + $item + "')";
        python($nodeString);

        //Get current x, y, z, rotation + translation
        
        currentTime -u 0 ($j);  //the -u 0 means it doesn't update the view port.
        $currX = `getAttr -t $i ($item+".translateX")`;
        $currY = `getAttr -t $i ($item+".translateY")`;
        $currZ = `getAttr -t $i ($item+".translateZ")`;
        $currRX = `getAttr -t $i ($item+".rotateX")`;
        $currRY = `getAttr -t $i ($item+".rotateY")`;
        $currRZ = `getAttr -t $i ($item+".rotateZ")`;
        
        
        //Get previous xyz rot + trans
        $prevX = `getAttr -t $j ($item+".translateX")`;
        $prevY = `getAttr -t $j ($item+".translateY")`;
        $prevZ = `getAttr -t $j ($item+".translateZ")`;
        $prevRX = `getAttr -t $j ($item+".rotateX")`;
        $prevRY = `getAttr -t $j ($item+".rotateY")`;
        $prevRZ = `getAttr -t $j ($item+".rotateZ")`;

        
        //Command Translation
        fprint $fileId2 ("fix    move"+$cleanName+$i+" all move/mesh mesh "+$cleanName+" linear "+($currX-$prevX)*$frame_rate+" "+($currY-$prevY)*$frame_rate+" "+($currZ-$prevZ)*$frame_rate+"\n");
        
        //calculate rotation since last frame:
        float $diffRX = $currRX - $prevRX;
        float $diffRY = $currRY - $prevRY;
        float $diffRZ = $currRZ - $prevRZ;
        
        // get quat directly
        python("quat1 = node.getRotation(quaternion=True)");
        currentTime -u 0 ($i);  //I do want to update the viewport here?  Maybe not for every bone/sphere.  Can I put this outside the loop?
        python("quat2 = node.getRotation(quaternion=True)");

        //maybe put time back?
        python("quat3 = quat1.inverse() * quat2");

        python("aaxis = om.MVector()");
        python("angUtil = om.MScriptUtil()");
        python("angUtil.createFromDouble(0)");
        python("angDoub = angUtil.asDoublePtr()");

        python("quat3.getAxisAngle(aaxis,  angDoub)");
        python("theta =  om.MScriptUtil.getDouble(angDoub)");

        $axisX = python("aaxis[0]");//MAY NEED TO NORMALIZE AXIS!  - nope, probably not due to liggghts using period.
        $axisY = python("aaxis[1]");
        $axisZ = python("aaxis[2]");
        //$pyQuatW = python("quaternion.w");  
        $aangle = python("math.degrees(theta)");  //doing the math in python while variable is there.
        $rots[$p] = $aangle;

      

 
        //print axis and period:  
        if ($aangle != 0)
        {
            float $period = (360/$aangle) * (1/$frame_rate);          //calculate period from angle
            fprint $fileId2 ("fix    rotate"+$cleanName +$i+" all move/mesh mesh "+$cleanName+" rotate origin "+$prevX+" "+$prevY+" "+$prevZ+" axis "+$axisX+" "+$axisY+" "+$axisZ+" period "+$period+" #angle is "+$aangle+"\n");      
        }
        else
        {
            fprint $fileId2 ("# did not fix    rotate"+$cleanName +$i+" all move/mesh mesh "+$cleanName+"Angle is "+$aangle+"\n");
        }
    $p = $p+1; //increement angle storage index
    }
    fprint $fileId2 ("run "+$timesteps_per_frame+"\n");


    $p = 0; //reset index

    for ($item in $bones)
    {

    string $buffer[];
    tokenize $item ":" $buffer;
    string $cleanName = $buffer[size($buffer)-1];

        //have to check ang again as not storing it!
        currentTime -u 0 ($j);
        $currRX = `getAttr -t $i ($item+".rotateX")`;
        $currRY = `getAttr -t $i ($item+".rotateY")`;
        $currRZ = `getAttr -t $i ($item+".rotateZ")`;
              
        //Get previous xyz rot + trans
        $prevRX = `getAttr -t $j ($item+".rotateX")`;
        $prevRY = `getAttr -t $j ($item+".rotateY")`;
        $prevRZ = `getAttr -t $j ($item+".rotateZ")`;
        
        //calculate rotation since last frame:
        float $diffRX = $currRX - $prevRX;
        float $diffRY = $currRY - $prevRY;
        float $diffRZ = $currRZ - $prevRZ;
        

        //do y
        if ($rots[$p] != 0)
        {
            fprint $fileId2 ("unfix rotate"+$cleanName+$i+" #angle is "+$rots[$p]+"\n");
        }  

        $p = $p+1;
        fprint $fileId2 ("unfix move"+$cleanName+$i+"\n");

    }

    //Replace the meshes!
    fprint $fileId2 ("undump dumpstl1\n");   //unfix the dump...
    fprint $fileId2 ("unfix cont1\n"); //and unfix the contacts
    for ($item in $bones)
    {

    string $buffer[];
    tokenize $item ":" $buffer;
    string $cleanName = $buffer[size($buffer)-1];
        fprint $fileId2 ("unfix "+$cleanName+"\n");   //so you can unfix each mesh....
        fprint $fileId2 ("fix   "+$cleanName+" all mesh/surface file "+$cleanName+"_"+$i+".stl type 1 curvature_tolerant yes\n"); //so you can fix the new mesh
    }
    fprint $fileId2 ("fix cont1 all wall/gran model hertz tangential history mesh n_meshes "+(size($bones)+1)+" meshes tray ");
    for ($item in $bones)
    {
        string $buffer[];
        tokenize $item ":" $buffer;
        string $cleanName = $buffer[size($buffer)-1];
        fprint $fileId2 (" "+$cleanName+" ");
    }
    fprint $fileId2 ("\n");
    fprint $fileId2 ("dump  dumpstl1 all mesh/vtk $e post/footcomp2_*.vtk id\n"); //and refix the dump.
    for ($item in $bones)
    {
        string $buffer[];
        tokenize $item ":" $buffer;
        string $cleanName = $buffer[size($buffer)-1];
        fprint $fileId2 (" "+$cleanName+" ");

    }



}


fclose $fileId2;
}

